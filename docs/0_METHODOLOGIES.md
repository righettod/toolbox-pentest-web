# üìö Methodologies

> üì° **Note**: Use the TOC provided by the GitHub MD file rendering named `Outline`.

üè° [Back to home](README.md).

## Methodology personal to assess a web app in white box mode

**Flow:**

```mermaid
flowchart LR
    A((Anonymous)) -->B(Authenticated with low privileges)
    B --> C(Authenticated with high privileges)
    C --> D(System read and write access)
    D --> E((System shell))
```

**Step 1:**

üîé Identify in code all features accessible anonymously and confirm access via an HTTP call.

**Step 2:**

üîé Search into elements identified in step 1 for vulnerability allowing to pass in an authenticated state (normal or privileged):

* In case of SQLI: Verify if stack queries are supported, if NOT verify the presence of a reset password feature or any feature allowing to retrieve/obtain some kind of access token...
* In case of serialization: Verify if control is performed on the data received (signature, HMAC...)...
* Take care to logic applied in order to identify any issue in it (ex: custom algo or predictable generated elements like reset token...).
* ...

**Step 3:**

üîé Search for a way (doc, install file, hard-coded, enumeration...) to obtain a user or a list of users in order to leverage the step 2.

**Step 4:**

üìñ Use element gathered in steps 1+2+3 to obtain an authenticated session.

üìç **Needed if required for the next step:** If the access was not privileged then repeat step 2+3 targeting feature accessible to the authenticated user in order to pass in privileged mode.

**Step 5:**

üìñ Use element gathered in **step 4** to look for a way to interact with the OS filesystem directly (ex: XXE) or via a relay like the DB (ex: custom extension).

**Step 6:**

üìñ Use element gathered in **step 5** to look for vulnerability to gain RCE and then a reverse shell.

## Methodology for SAML based authentication flow evaluation

### Documentation

* [Specifications bundle](https://docs.oasis-open.org/security/saml/v2.0/saml-2.0-os.zip).
  * [Glossary](https://docs.oasis-open.org/security/saml/v2.0/saml-glossary-2.0-os.pdf).
  * [Security and Privacy Considerations](https://docs.oasis-open.org/security/saml/v2.0/saml-sec-consider-2.0-os.pdf).
  * [Assertions and Protocols](https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf).
  * [Authentication Context](https://docs.oasis-open.org/security/saml/v2.0/saml-authn-context-2.0-os.pdf).
  * [Bindings](https://docs.oasis-open.org/security/saml/v2.0/saml-bindings-2.0-os.pdf).
  * [Metadata](https://docs.oasis-open.org/security/saml/v2.0/saml-metadata-2.0-os.pdf).
  * [Profiles](https://docs.oasis-open.org/security/saml/v2.0/saml-profiles-2.0-os.pdf).
  * [Conformance](https://docs.oasis-open.org/security/saml/v2.0/saml-conformance-2.0-os.pdf).

### Methodology: How to Hunt Bugs in SAML?

* [Part I](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/).
* [Part II](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two).
* [Part III](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three).

### Tools

* [Custom python utility script](../templates/inspect_saml_request_response.py).
* Burp extension named  [SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e).
* [SAML online toolkit](https://www.samltool.com/online_tools.php).
* [SAML online validator](https://samltool.io/).
* [SAML decoder and parser](https://www.scottbrady91.com/tools/saml-parser).
* [SAML developer tools](https://developer.pingidentity.com/en/tools.html).

### Different types of XML signatures

üí° Based on this [source](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/#xml-signatures):

* A **enveloping signature** is when the signature wraps the signed resource.
* A **enveloped signature** is when the signature itself is a descendant of the resource it‚Äôs signing.
* A **detached signature** is neither wrapping nor is it wrapped by the resource to be signed. Instead, it is wholly separate from the signed resource.

## Methodology for code review

> ü§ù Based on the video, named [Code Review Strategies](https://pentesterlab.com/videos/280), from the [PentesterLab Code Review badge of PentesterLab](https://pentesterlab.com/badges/codereview).

![CodeReviewStrategies](CodeReviewStrategies.png)

ü§î Possible strategies:

1. **Weakness** identification orientation (horizontal approach):
    * Review the code of *all functions even if they are not called by a function using user input*.
    * ‚úÖ This provides a pretty good coverage.
    * ‚ùå It is time consuming so require to have the time to do it.
2. **Vulnerability** identification orientation (vertical top-down or down-top approach):
    * Review the code of *all functions in the call tree initiated by (top-down) or landing on (down-top) a user input*.
    * ‚úÖ This requires less time and allow to focus on some parts of an app.
    * ‚ùå As the coverage is partial it does not provide a full feedback about the security of the app.
3. **Feature** orientation:
    * It uses the *vulnerability identification orientation in vertical top-down approach* and review all the functions that are part of a targeted features (for example "password reset").
    * üí° It is the recommended one when possible.

## Methodology for ports scanning

> ü§ù All credit for this **methodology** goes fully to **[Moses Frost](https://linktr.ee/mosesrenegade)**.

üìç Foundation fact:

1. [Masscan](https://github.com/robertdavidgraham/masscan) is ideal for **speed** over **accuracy**.
2. [Nmap](https://github.com/nmap/nmap) is ideal for **accuracy** over **speed**.

üìñ The methodology is composed of the following phases:

```mermaid
flowchart LR
    A[(List of hosts)]
    A -- Seed --> B(Masscan)
    B -- Produce --> C[(List of open ports<br/>by hosts)]
    C -- Seed --> D(Nmap)
    D -- Produce --> E[(List of open services<br/>by hosts)]
```

üí° Key points:

* Always scan all **TCP** port range `0-65535`.
* **Never scan UDP in the same way than TCP**: Always use tools with valid **UDP payloads**.
* Consider dividing the ports range like this:
  * `0-1024`: Default server ports.
  * `1025-10000`: Commonly used server ports.
  * `30000-32767`: Kubernetes Nodes NodePorts services.
  * `10001-29999` and `32768-65535`: Customizable by the end customers.

## Methodology for Cloud penetration testing

> üë®‚Äçüíª Contains all information that I have gathered/created during my studies/work/training on this topic.

> ü§ù All credit for this **methodology** as well as the **Assets Collection Pipeline** concepts go fully to **[Moses Frost](https://linktr.ee/mosesrenegade)**.

### Possible scenario

| **Scenario**                                          | **Objective**                                                                                                                                                                                                                    |
|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Perimeter breach assessment                            | This scenario identify the perimeter assets and attempts to pivot from cloud-based assets to internal assets (from outside to inside evaluation).                                                                                                                        |
| Exposed keys, insider threats and accidental exposure | This scenario assumes that identity management keys or other sensitive materials were stolen. The goal is to identify the capabilities provided by such credentials from a compromising perspective.                                                              |
| Assumed breach                                        | This scenario skip the reconnaissance and discovering phase. It is designed to allow the testing team to help the customer or internal blue team to understand the impact of a breach using a specific cloud-based starting point. |
| Assumed container breach                              | This scenario assumes that a container is compromised. The goal is to identify the attacker capabilities to expand the compromising from this starting point.                                                                      |
| Attack surface discovery                              | This scenario can be part of a **Continuous Attack Surface Management** (CASM) service. This technique is used to find and discover exposed systems that can be targeted by an attacker.                       |

### Methodology

üìñ The methodology is composed of the following phases:

```mermaid
flowchart TD
    A[Reconnaissance/Data Collection] --> B(Data Analysis for Discovery)
    B --> C(Scanning/Mapping)
    C --> D(Vulnerability/Discovery)
    D --> E(Exploitation/Elevation)
    E -->F(Post Exploitation Reconnaissance)
    F--> G(Persistence/Pivot Pivoting)
    G--> H[Lessons Learned/Remediation]
```

üè≠ The **Assets Collection Pipeline** flow is the following:

```mermaid
flowchart LR
    subgraph Seed Value
        A[Domains]
    end
    subgraph Hosts
        A --> B(Subdomains/Hostnames)
        A --> C("Hosts (IP)")
    end
    subgraph Applications
        B --> D(Routes/Endpoints)
        B --> E(Ports)
        C --> E
    end
    subgraph Classifier   
        E --> F(Technology)
        D --> F
    end
    subgraph Detection
        F --> G[Issues]
    end
```

üè≠ My implementation of the **Assets Collection Pipeline** is composed of the following phases:

```mermaid
sequenceDiagram
    actor DOM as righettod
    participant CAD as Cloud Assets Discovery
    participant ADS as Attack Surface Discovery
    participant ADA as Attack Surface Analysis
    DOM->>CAD: Provide the target's base domain<br/>like "righettod.eu"
    CAD->>CAD: Use different open data providers<br/>and techniques to find exposed assets
    CAD->>CAD: Produce a CSV with identified assets
    CAD->>ADS: Pass the relay
    ADS->>ADS: Consume the CSV data
    ADS->>ADS: Scan each asset for exposed services
    ADS->>ADS: Produce a CSV with identified 
    ADS->>ADA: Pass the relay
    ADA->>ADA: Consume the CSV data
    ADA->>ADA: Identify interesting services<br/>using different custom rules
    ADA->>ADA: Produce a CSV with selected services
    ADA->>DOM: Pass the relay
    DOM->>DOM: Consume the CSV data
    DOM->>DOM: Analyze each service for<br/>presence of vulnerabilities
    DOM-->>DOM: Identify, document and exploit<br/>any vulnerability according<br/>to the provided scope
```

üì¶ My **Assets Collection Pipeline** implementation's toolkit is composed of the following items:

* üìë **Cloud Assets Discovery** phase is handled by this [custom scripts](../scripts/discover-cloud-based-assets.sh) and this [custom scripts](../scripts/discover-cloud-based-subdomains-takeover-opportunities.py).
* üìë **Attack Surface Discovery** phase is handled by this [custom scripts](../scripts/attack-cloud-based-assets.sh).
* üìê **Attack Surface Analysis** phase is currently a manual operation.

üí° For the **Attack Surface Discovery** phase, the tools [GoWitness](https://github.com/sensepost/gowitness) should be used to obtain a screenshot of every website identified via the capture of the *welcome page* for each of them.

üíª The following command can be used - Docker version is used to prevent any issues with the dependencies of GoWitness and ensure to always use the latest stable release:

```powershell
PS> get-content .\urls.txt
https://righettod.eu
https://lessentiel.lu
PS> docker run --rm -v "$pwd/:/data" leonjza/gowitness gowitness file -f urls.txt
# Processing ...
PS> get-childItem .\screenshots\
https-righettod.eu.png
https-lessentiel.lu.png
PS> docker run --rm -v "$pwd/:/data" -p7171:7171 leonjza/gowitness gowitness server --address :7171
# Open http://localhost:7171 to access to the report viewer
```

### Control plane vs Data plane

* **Control plane** of a cloud environment is the plane that deals with connectivity and orchestration in the cloud.
* **Data plane** is how users interact with these systems and is typically where our attackers and target organizations run their standard operations.

### Cloud user accounts enumeration

üí° Some cloud providers, like Azure, have their authentication feature providing a [discrepancy factor](https://cwe.mitre.org/data/definitions/204.html) allowing to:

1. Identify if a domain has its authentication handled by Azure via the presence of a **tenant**.
2. A user account exists or not in the **tenant**.

üîé Example with Azure using `https://login.microsoftonline.com/` (tested on **August 2023**):

* When the **tenant** is not present then the following response is provided:

![AzureUserEnum00](AzureUserEnum00.png)

* When the user is **NOT** present in a **tenant** then the following response is provided:

![AzureUserEnum01](AzureUserEnum01.png)

* When the user is present in a **tenant** then the following response is provided:

![AzureUserEnum02](AzureUserEnum02.png)

```bash
# Tested on August 2023
# Following endpoints can be used to identify if a tenant is hosted on Azure
## Test for company "excellium-services.lu"
$ curl -sk "https://login.microsoftonline.com/excellium-services.lu/v2.0/.well-known/openid-configuration" | jq -r ".token_endpoint"
https://login.microsoftonline.com/6fbe6025-1d0f-498d-ae44-23b34f048283/oauth2/v2.0/token
## Test for company "righettod.eu"
$ curl -sk "https://login.microsoftonline.com/righettod.eu/v2.0/.well-known/openid-configuration" | jq -r ".token_endpoint"
null

# Same objective but using another endpoint
$ curl -sk "https://login.microsoftonline.com/getuserrealm.srf?login=excellium-services.lu&json=1" | jq -r ".NameSpaceType"
Managed
$ curl -sk "https://login.microsoftonline.com/getuserrealm.srf?login=righettod.eu&json=1" | jq -r ".NameSpaceType"
Unknown
```

```bash
# Tested on August 2023
# Following endpoints can be used to identify if a user exists or not in a tenant
## Response when the user exists
$ curl -sk "https://login.microsoftonline.com/common/GetCredentialType" --data '{"Username":"drighetto@excellium-services.lu"}' | jq -r ".IfExistsResult"
0
## Response when the user DOES NOT exist
$ curl -sk "https://login.microsoftonline.com/common/GetCredentialType" --data '{"Username":"mlqds@excellium-services.lu"}' | jq -r ".IfExistsResult"
1
```

üöÄ This [tool](https://github.com/0xZDH/Omnispray) can be used to perform the discovery of exiting users via the behavior described above.

üöÄ This collection of [web services](https://aadinternals.com/osint/) can be used to obtain information about a **tenant**.

### Cloud user accounts attack

üìñ The approach is composed of the following phases:

```mermaid
flowchart TD
    A[Understand Username Structure] --> B(Credential Stuffing Attack)
    B --> C(Credential Stuffing + Rules)
    C --> D(Custom Wordlist)
    D --> E(Wordlist + Rules)
    E -->F(Password Spray Attack)
    F--> G[Dictionary Attack]
```

üëÄ Note:

* üü¢ **Credential Stuffing Attack**: Leverage known password breaches.
* üü¢ **Password Spray Attack**: Rotate one password for many users.
* üü† **Dictionary Attack**: Potentially use this in a live system, depending on the list.
* üî¥ **Brute force password Attack**: Never use this in a live system, it will not work.

### Mapping of service names between AWS and Azure

| **Amazon AWS**                                  | **Microsoft Azure**                     |
|-------------------------------------------------|-----------------------------------------|
| Amazon Elastic Compute Services (EC2)           | Azure Virtual Machines                  |
| Virtual Private Cloud (VPC)                     | Virtual Network                         |
| Amazon Relational Database Service              | SQL Database, Azure Database for MySQL  |
| S3                                              | Azure Blog Storage                      |
| Lambda                                          | Azure Functions                         |
| Elastic Kubernetes Service                      | Azure Kubernetes Service                |
| Identity and Access Management (Authentication) | Azure Active Directory (Authentication) |
| Identity and Access Management (RBAC)           | Azure Role Based Access Control (RBAC)  |
| AWS Directory Services                          | Azure Active Directory Domain Services  |
| Key Management Service                          | Key Vault                               |

### Mapping of role between On Premise, Azure and AWS

| **On Premise**                               | **Azure**                                                            | **AWS**                                                                    |
|----------------------------------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------|
| Server (File Server, AD Server, SQL Server)  | Services (Azure Files, Azure AD DS, Azure SQL)                       | Services ([EFS](https://aws.amazon.com/efs/), AWS Directory Services, RDS) |
| AD Domain Services: Forest                   | Azure Subscription, Azure AD Tenant                                  | AWS Organizations, AWS Account                                             |
| Domain Admin (or Enterprise Admin)           | Global Administrator                                                 | Root User                                                                  |
| Backup Adminnistrator (Roles-based Admin)    | Owner, Contrubutor, Reader                                           | AWS Roles: `S3:*`, `EC2:*`                                                 |
| Management Interfaces (RDP, PowerShell, SMB) | REST API, CLI Tools, PowerShell, (RDP can be made available for VMS) | AWS CLI Tools, REST APIs, (RDP can be made available for VMs)              |
| IP Subnetting, Firewalling, RFC 1918, NAT    | Azure Virtual Network                                                | AWS VPC                                                                    |

### High-level view of identity in Microsoft

| **Types**                 | **Microsoft On Premise AD**           | **Microsoft Azure AD**                                                                                                        |
|---------------------------|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| Communication Protocol    | LDAP/Kerberos                         | HTTPS                                                                                                                         |
| Authentication Protocol   | Microsoft Kerberos and/or NTLMv2      | OAuth, SAML, WS-Federation, [SCIM](https://learn.microsoft.com/en-us/azure/active-directory/architecture/sync-scim), Kerberos |
| Global Structure          | Domains and Forests                   | Tenants                                                                                                                       |
| Organizational Structure  | Tree and Folder Based                 | No Structure                                                                                                                  |
| Access Control Mechanisms | "File Based", Granular Access Control | Function Based Access Controls and Roles                                                                                      |

### Overview of the Azure AD roles

```mermaid
flowchart LR
    A((Roles)) -.-> B{{Azure AD Administrators roles}}
    A -.-> C{{Azure RBAC roles}}
    subgraph Manage Azure AD Services itself
        B --> D[Global admin]
        B --> E[User admin]
        B --> F[Billing admin]
    end
    subgraph Manage Azure resources
        C --> G[Owner]
        C --> H[Contributor]
        C --> I[Reader]
    end
```

| **Role**              | **Description**                                                                                                                  |
|-----------------------|----------------------------------------------------------------------------------------------------------------------------------|
| Global administrator  | Role assigned to the user that originally signed up for the Azure Tenant. It is the highest privilege account in an organization. |
| User administrator    | This role can add/remove users as well as change passwords.                                                                      |
| Billing administrator | This role can add new services and subscriptions but cannot add/remove roles.                                                    |
| Owner                 | This role has full access on the target resources (owner).                                                                      |
| Contributor           | This role has read/write access on the target resources but not owner.                                                          |
| Reader                | This role has read-only access on the target resources.                                                                         |

üí° **Azure RBAC** can manage Azure Resources like Virtual Machines, Serverless Functions, SQL Services, etc.

üí° **Azure AD Administrators** manage Azure Active Directory Resources, Tenant-level scope.

‚ö† **Azure AD Administrators** do not manage the Azure Resources **BUT** can provide *access to those resources*.

### App Consent concepts in Azure

> ‚ö† By default in Azure AD, **every user can grant access to third-party applications regardless of whether these applications are verified** (this default behavior can be changed by an administrator).

* Azure AD has many applications that are **multi-tenant** and registered on the platform.
* A user or an administrator can **GRANT** a **CONSENT** to those applications: Once such *consent* granted, an application can then query resources on behalf of that user.

üí° App Consent is an OAuth 2.0 flows concept in practice.

### Microsoft Graph API

> üí° It provides a singular universal API to interact with all Microsoft services ecosystem.

Microsoft Graph requires permissions to be set from Azure AD or an RBAC like system that ca provide the appropriate roles. There are **4 constraints** in the Microsoft Graph permissions model:

| **Constraint**    | **Description**                                                                                                                                                                                                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **All**           | When the constraint is **all**, it is providing global access to all objects against the service. This means that if you provide a user with *Mail.read.all*, hey can read all the email in the system.                                                                          |
| **Shared**        | This permits operation against the logging-in user's resources, as well as any objects that were shared with that user. For example, if a user has shared a calendar with the logging-in user, the graph permission will allow the logging-in user the access the shared calendar. |
| **AppFolder**     | This grant read/write to files and folders in OneDrive. This is the only supports Microsoft accounts.                                                                                                                                                                             |
| **NoConstraints** | Without constraints, you only get access to the data and objects of the signed-in user.                                                                                                                                                                                           |

üìñ [Microsoft Graph permissions reference](https://learn.microsoft.com/en-us/graph/permissions-reference).

üíª Microsoft, provide and maintain this [Postman collection](https://www.postman.com/microsoftgraph/workspace/microsoft-graph/overview), to be able to use the Microsoft Graph API.

### Amazon ARN

**ARN** stands for **A**mazon **R**esource **N**ame.

üìç ARNs are hidden or private to the user.

üìë Format:

```text
arn:partition:service:region:account-id:resource-id

arn:partition:service:region:account-id:resource-type/resource-id

arn:partition:service:region:account-id:resource-type:resource-id
```

üíª Example:

`arn:aws:iam::123456789012:user/dev/product/*`

1. `arn` is the common prefix to all ARN.
2. `aws` is the partition, that will typically always be **aws**. However, it can be **china** which is a different partition than **aws**.
3. `iam` is the AWS service used.
4. `[empty]` is a value indicating that is applied to any region.
5. `123456789012` is the account identifier.
6. `user/dev/product/*` is the resource identifier to which the ARN was referring to (wildcard character is supported).

üìñ [Amazon ARN reference](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html).

### AWS Confused Deputy vulnerability

üìã Context:

*A service provider want to read a bucket or perform actions on your behalf.*

üìê Setup:

*To do this, the service provider ask you to create a role in which they can assume the role (AssumeRole).*

üêú Vulnerability:

**AssumeRole** in AWS allows you to assume a role; think of this like *masquerading* as a role.

The vulnerability in many of these configurations is that *anyone can assume the role* is they know 2 elements: **Account ID** + **Rolename**.

üìñ [The confused deputy problem explained](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html).

üìñ [AWS CLI STS AssumeRole](https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html).

### Cloud Native Computing Foundation

* [CNCF Homepage](https://www.cncf.io/).
* [CNCF Cloud Native Interactive Landscape](https://landscape.cncf.io/).
* [CNCF Cloud Native Trail Map](https://github.com/cncf/trailmap).

üó∫ The CNCF **[Cloud Native Trail Map](https://github.com/cncf/trailmap)** provides an overview for enterprises starting their cloud native journey:

![CNCF Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)

### AWS Lambda and Azure Functions properties

| AWS Lambda                                                                                                                 | Azure Functions                                                                                                 |
|----------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| It is an environment that is running in a **container-based** system.                                                         | Do not containerize at the Function layer.                                                                      |
| Can be executed by the AWS CLI.                                                                                            | Run inside of Windows or Linux.                                                                                 |
| Require Amazon IAM permissions to execute the function.                                                                    | Can ship with a public gateway function or can be made private.                                                 |
| Will only be exposed on the Internet through the API gateway service.                                                      | Functions are grouped together based on an app, multiple functions in an app mean they all work in the same OS. |
| Execute when an event is triggered BUT will not be directly triggerable from the outside world without the gateway itself. | The entire system has write access on the disk of the OS.                                                       |
| Are limited to a single function typically, but multiple Lambdas can be grouped together.                                  | All functions are in `D:\home\site\wwwroot\<function-name>`.                                                    |
| They don't have internal endpoints for services unless they are in a VPC.                                                  | Secrets are typically kept on disk in **plaintext** in `D:\home\data\Functions\secrets`.                        |
| They spin down after 15 minutes and take 45 seconds to spin up.                                                            | The environment variables are fully readable by using the `SET` command.                                        |
| Securing lambda is hard, no agent can be installed.                                                                        | The app does have outbound internet access.                                                                     |
| Container based on **Firecracker** project.                                                                                | Based on the **Kudu** project.                                                                                  |
| By default, Lambda functions have access to the public internet.                                                           | A web shell console is provided to developers to be able to work with the underlying layer.                     |
|                                                                                                                            | Spin down depends on the **subscription plan**.                                                                 |

üåé Sources:

* [Firecracker](https://firecracker-microvm.github.io/) project.
* [Kudu](https://github.com/projectkudu/kudu) project.
* [AWS Lambda Internet access](https://docs.aws.amazon.com/lambda/latest/operatorguide/networking-vpc.html) documentation.
* [Azure Functions timeout](https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale#timeout) documentation.

### Kubernetes

#### Components overview

![k8s-componenents-overview](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

üåé [Source of the image](https://kubernetes.io/docs/concepts/overview/components/).

#### Type of deployments of a Kubernetes cluster

üì¶ Several deployment options exist:

* **Completely Cloud Managed**: This is the most common way Kubernetes runs for many individuals. It is the service provider-managed model, typically a cloud-provider model (ex: Amazon EKS, Azure Kubernetes Service, GKE, etc.).
* **Turnkey Commercially Supported**: This model is where the cloud service provider is not managing the entire environment (ex: Rancher, VMWare).
* **On-Premises**: Many commercial companies have deployed Kubernetes in an on-premise data center model, where the commercial offering has deployed all relevant components.
* **Custom**: These are various options for Kubernetes builds that can run in many ways.

#### Interesting points

üí° From a general perspective:

* `kubeadm` is the main administrative tools that will **control the cluster** and allow an administrator to connect to the Kubernetes environment. It requires a configuration file on the host with the right permissions to operate the cluster.
* `kubectl` is the control software that can perform **container** actions and **services mesh** actions.
* `kubelet` is the agent that takes in items from the Kubernetes API that work on the nodes. Even if it is not a tool typically run by administrators, it is a critical part of the control plane.

üòà From an attacker perspective:

* `kubectl` stores login information in the main configuration files by combining multiple configuration files into the environment variable called `KUBECONFIG`.
* By default, a Pod is associated with a service account, and a credential (token) for that service account is placed into the folder `/var/run/secrets/kubernetes.io/<user or role>/{token,namespace,ca.crt}` where ([source](https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/#directly-accessing-the-rest-api)):
  * The **token** contains the access token (**JWT** format).
  * The **namespace** contains the container namespace.
  * **ca.crt** is the CA certificate file validating the CA chain. The CA is in the Kubernetes control plane.
* üìç **RBAC mechanism** is only present if the version of the Kubernetes cluster is **>= 1.8**.
* üìç Kubernetes **API Server** is a target of preference if it is available.
* üìç `kubelet` and `kubeadm` tools use certificate to make the communications possible so they will be the focus on the attack path.
* [User accounts versus Service accounts](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#user-accounts-versus-service-accounts).
* When deploying a **backdoored container** then the [DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/) *kind of deployment* is recommanded to ensure that the container is deployed on all node of the cluster ([deployments reference](https://kubernetes.io/docs/concepts/workloads/controllers/)).
  * Example of a minimalist descriptor to deploy a backdoored container as a **DaemonSet** - Deploy it via `kubectl apply -f daemonset.yaml`:

```yaml
# See following references for details:
# https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
# https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#securitycontext-v1-core
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: evil-backdoored-container
  namespace: default
spec:
  selector:
    matchLabels:
      name: evil-backdoored-container
    spec:
      containers:
      - name: evil-backdoored-container
        image: righettod/evil-backdoored-container
        securityContext:
            # Run container in privileged mode.
            # Processes in privileged containers are essentially equivalent to root on the host
            privileged: true
            # AllowPrivilegeEscalation controls whether a process 
            # can gain more privileges than its parent process
            allowPrivilegeEscalation: true
```

### Additional references and tools

* [Azure AD / Microsoft 365 hacking and admin toolkit](https://aadinternals.com/).
* [Omnispray - Modular Enumeration and Password Spraying Framework](https://github.com/0xZDH/Omnispray).
* [cloud_enum - Enumerate public resources in AWS, Azure, and Google Cloud](https://github.com/initstring/cloud_enum).
* [MicroBurst - A collection of scripts for assessing Microsoft Azure security](https://github.com/NetSPI/MicroBurst).
* [Hydra - Multipurpose account brute force tool](https://manpages.ubuntu.com/manpages/trusty/man1/hydra.1.html).
* [A tool to reduce the password list](https://manpages.ubuntu.com/manpages/jammy/man1/pw-inspector.1.html).
* [Introducing the Office 365 Attack Toolkit created by MDSec](https://www.mdsec.co.uk/2019/07/introducing-the-office-365-attack-toolkit/).
* [PACU - AWS exploitation framework](https://github.com/RhinoSecurityLabs/pacu).
* [KubeHunter - Hunt for security weaknesses in Kubernetes clusters](https://github.com/aquasecurity/kube-hunter).
* [Peirates - Kubernetes Penetration Testing tool](https://github.com/inguardians/peirates).
* [Autossh - Automatically restart SSH sessions and tunnels](https://github.com/Autossh/autossh) + [How to Get Started With Autossh](https://blog.invgate.com/autossh).
* [Sliver - Open source cross-platform adversary emulation/red team framework](https://github.com/BishopFox/sliver).
* [MosesRenegade - Statically compiled tools that could be used in engagements](https://github.com/mosesrenegade/tools-repo).

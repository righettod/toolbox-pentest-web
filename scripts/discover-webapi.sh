#!/bin/bash
###
# Script to discover hidden web API.
# Cf https://github.com/ffuf/ffuf#usage
# Tips: By default do not ignore the HTTP 500
# Use -fl X to skip responses with X number of lines
#     -fs X to skip responses with a response size of X bytes
#     -fw X to skip responses with X words
#     -fl 12,25 to skip responses with 12 or 25 number of lines (same syntax for 'fs' and 'fw')
###
EXTRA_FFUF_OPTS="-s"
COOKIES="Cookie: a=b"
AUTHENTICATION_HEADER="Authorization: Bearer ABCDEF"
###
USER_AGENT="User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57"
IGNORE_HTTP_CODES="301,302,400,401,403,404"
THREAD_COUNT="10"
TIMEOUT=30
PROXY=""
###
DICT_HOME="/tools/sec-lists/Discovery/Web-Content"
REPORT_HOME="/tools/reports"
FFUF_RUN_STORAGE="$REPORT_HOME/ffuf_run_files_api"
EDP_NAMES_CONSOLIDATED_DICT="/tmp/consolidated-endpoint-names.tmp"
###
if [ "$PROXY" != "" ];
then
	ffuf_proxy="-x $PROXY"
else
	ffuf_proxy=""
fi
base_target=$1
rm -rf $FFUF_RUN_STORAGE 2>/dev/null 
mkdir $FFUF_RUN_STORAGE 2>/dev/null
rm $EDP_NAMES_CONSOLIDATED_DICT 2>/dev/null
opts="$EXTRA_FFUF_OPTS $ffuf_proxy -fc $IGNORE_HTTP_CODES -c -ic -timeout $TIMEOUT -t $THREAD_COUNT -o $REPORT_HOME/ffuzz-api.json -of json -od $FFUF_RUN_STORAGE"
# Phase 1: Try using HTTP method GET with dicts of common entries
dicts=("graphql.txt" "swagger.txt" "spring-boot.txt" "axis.txt")
for dict in ${dicts[@]}; do
	entries_count=$(wc -l $DICT_HOME/$dict | cut -d' ' -f1)
	echo -e "\e[93m[PHASE 1][HTTP GET              ] Test using SecLists dictionary '$dict' ($entries_count entries) ...\e[0m"
	ffuf $opts -w $DICT_HOME/$dict -H "$COOKIES" -H "$AUTHENTICATION_HEADER" -H "$USER_AGENT" -u $base_target/FUZZ		
done
# Phase 2: Try using several HTTP methods with a dict of common endpoint names
dicts=("api/actions-lowercase.txt" "api/objects-lowercase.txt" "raft-small-words-lowercase.txt")
http_methods=("HEAD" "OPTIONS" "GET" "TRACE" "POST" "PUT" "DELETE" "INVALID" "PURGE" "PROPFIND" "PROPPATCH" "MKCOL" "COPY" "MOVE" "LOCK" "UNLOCK" "VERSION-CONTROL" "REPORT" "CHECKOUT" "CHECKIN" "UNCHECKOUT" "MKWORKSPACE" "UPDATE" "LABEL" "MERGE" "BASELINE-CONTROL" "MKACTIVITY" "ORDERPATCH" "ACL" "PATCH" "SEARCH" "ARBITRARY" "BIND" "LINK" "MKCALENDAR" "MKREDIRECTREF" "PRI" "QUERY" "REBIND" "UNBIND" "UNLINK" "UPDATEREDIRECTREF")
for dict in ${dicts[@]}; do
	cat $DICT_HOME/$dict >> $EDP_NAMES_CONSOLIDATED_DICT
done
grep -Ev '[\.\s@\/]' $EDP_NAMES_CONSOLIDATED_DICT | grep -Ev '^[0-9]' | sort -u > $EDP_NAMES_CONSOLIDATED_DICT.work
mv $EDP_NAMES_CONSOLIDATED_DICT.work $EDP_NAMES_CONSOLIDATED_DICT
entries_count=$(wc -l $EDP_NAMES_CONSOLIDATED_DICT | cut -d' ' -f1)
for http_method in ${http_methods[@]}; do
	mth=$(printf "%-17s" "$http_method")
	echo -e "\e[93m[PHASE 2][HTTP $mth] Test using custom dictionary '$(basename $EDP_NAMES_CONSOLIDATED_DICT)' ($entries_count entries) ...\e[0m"
	ffuf -X $http_method -H "Content-Type: application/json" $opts -H "$COOKIES" -H "$AUTHENTICATION_HEADER" -H "$USER_AGENT" -w $EDP_NAMES_CONSOLIDATED_DICT -u $base_target/FUZZ
done
# Phase 3: Derivation of the phase 2 using a common initial api context path
context_paths=("user" "users" "account" "accounts" "server")
for context_path in ${context_paths[@]}; do
	echo -e "\e[93m[PHASE 3][HTTP GET              ] Test using '$context_path' base context path using custom dictionary '$(basename $EDP_NAMES_CONSOLIDATED_DICT)' ($entries_count entries) ...\e[0m"
	ffuf $opts -w $EDP_NAMES_CONSOLIDATED_DICT -H "$COOKIES" -H "$AUTHENTICATION_HEADER" -H "$USER_AGENT" -u $base_target/$context_path/FUZZ	
done

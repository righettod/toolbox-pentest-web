import com.ibm.msg.client.jms.*;
import com.ibm.msg.client.wmq.WMQConstants;

import javax.jms.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;

/**
 * Utility class to work with an IBM MQSERIES QUEUE MANAGER for manual inspection.<br>
 * Require MQ SERIES Java client libraries named "IBM MQ JMS and Java 'All Client'",<br>
 * Take the jars files from the "JavaSE" folder. See references named "mqc9-ibm-mq-v9-clients" for the link.<br>
 * JDK 11+ needed.<br>
 * <p>
 * Compilation command:<br>
 * <code>javac -cp $(pwd)/bcpkix-jdk15on-157.jar:$(pwd)/bcprov-jdk15on-157.jar:$(pwd)/com.ibm.mq.allclient.jar:$(pwd)/com.ibm.mq.traceControl.jar:$(pwd)/fscontext.jar:$(pwd)/jms.jar:$(pwd)/providerutil.jar MQSeriesUtils.java</code>
 * <p>
 * Execution command:<br>
 * <code>java -cp $(pwd)/bcpkix-jdk15on-157.jar:$(pwd)/bcprov-jdk15on-157.jar:$(pwd)/com.ibm.mq.allclient.jar:$(pwd)/com.ibm.mq.traceControl.jar:$(pwd)/fscontext.jar:$(pwd)/jms.jar:$(pwd)/providerutil.jar MQSeriesUtils</code>
 * <p>
 * In case of usage in a maven project, there is no need to download the client jar files because they are present in maven official repository:<br>
 * Refer to "https://github.com/ibm-messaging/mq-dev-patterns/blob/master/JMS/pom.xml#L37" for dependencies to use.<br>
 *
 * @see "https://www.ibm.com/support/pages/mqc9-ibm-mq-v9-clients#1"
 * @see "https://github.com/ibm-messaging/mq-dev-samples"
 * @see "https://developer.ibm.com/tutorials/mq-connect-app-queue-manager-containers/"
 * @see "https://stackoverflow.com/a/48145059"
 * @see "https://github.com/jmstoolbox/jmstoolbox"
 * @see "http://marketplace.eclipse.org/content/ibm-mq-explorer-version-92"
 * @see "https://github.com/ibm-messaging/mq-dev-patterns/blob/master/JMS/pom.xml#L37"
 */
public class MQSeriesUtils {
    //See https://stackoverflow.com/a/48145059
    private static final String DEFAULT_CHANNEL_ALWAYS_PRESENT = "SYSTEM.DEF.SVRCONN";
    //See https://www.ibm.com/docs/en/ibm-mq/8.0?topic=function-preparing-channels
    //See https://docs.asg.com/perf_tmq_3.0/content/rg/channel_activity.htm
    //See https://rmoff.net/2020/10/01/ibm-mq-on-docker-channel-was-blocked/
    private static final String[] POTENTIAL_EXISTING_CHANNELS = new String[]{DEFAULT_CHANNEL_ALWAYS_PRESENT, "SYSTEM.AUTO.RECEIVER", "SYSTEM.AUTO.SVRCONN",
            "SYSTEM.ADMIN.SVRCONN", "SYSTEM.DEF.CLUSRCVR", "SYSTEM.DEF.CLUSSDR", "SYSTEM.DEF.RECEIVER", "SYSTEM.DEF.REQUESTER", "SYSTEM.DEF.SENDER",
            "SYSTEM.DEF.SERVER", "DEV.ADMIN.SVRCONN", "DEV.APP.SVRCONN"};
    /* Taken from https://raw.githubusercontent.com/ibm-messaging/mq-dev-samples/master/gettingStarted/ */
    // Host name or IP address
    private static final String HOST = "righettod.local";
    // Listener port for your queue manager
    private static final int PORT = 11414;
    // Channel name
    private static final String CHANNEL = "DEV.APP.SVRCONN";
    // Queue manager name
    private static final String QMGR = "QM1";
    // User name that application uses to connect to MQ
    private static final String APP_USER = "app";
    // Password that the application uses to connect to MQ
    private static final String APP_PASSWORD = "passw0rd";
    // Queue that the application uses to put and get messages to and from
    private static final String QUEUE_NAME = "DEV.QUEUE.1";

    //This method assume that only the HOST, PORT, APP CREDS are known
    private static void discoverChannelNames(Path channelDict, final boolean useTLS) throws IOException {
        List<String> itemNames = Files.readAllLines(channelDict);
        itemNames.addAll(Arrays.asList(POTENTIAL_EXISTING_CHANNELS));
        System.out.printf("[+] Discover valid channel names (%s item names in guessing list):\n", itemNames.size());
        itemNames.parallelStream().forEach(c -> {
            String v = c.trim();
            try {
                //As we use parallel processing then each processing bloc have it own object instances
                HashMap<String, String> param = new HashMap<>();
                param.put(WMQConstants.WMQ_CHANNEL, v);
                param.put(WMQConstants.WMQ_QUEUE_MANAGER, "DO_NOT_EXISTS");
                connectToQM(false, useTLS, param);
            } catch (Exception e) {
                //Error when the channel do not exist is the following:
                //JMSCMQ0001: IBM MQ call failed with compcode '2' ('MQCC_FAILED') reason '2540' ('MQRC_UNKNOWN_CHANNEL_NAME').
                if (!e.getCause().getMessage().contains("('MQRC_UNKNOWN_CHANNEL_NAME')")) {
                    System.out.printf("%-25s => %s\n", v, e.getCause().getMessage());
                }
            }
        });
    }

    //This method assume that only the HOST, PORT, APP CREDS are known
    private static void discoverQueueManagerNames(Path qmDict, final boolean useTLS) throws IOException {
        List<String> itemNames = Files.readAllLines(qmDict);
        System.out.printf("[+] Discover valid queue manager names (%s item names in guessing list):\n", itemNames.size());
        itemNames.parallelStream().forEach(c -> {
            String v = c.trim();
            try {
                //As we use parallel processing then each processing bloc have it own object instances
                HashMap<String, String> param = new HashMap<>();
                param.put(WMQConstants.WMQ_CHANNEL, DEFAULT_CHANNEL_ALWAYS_PRESENT);
                param.put(WMQConstants.WMQ_QUEUE_MANAGER, v);
                connectToQM(false, useTLS, param);
            } catch (Exception e) {
                //Error when the queue manager do not exist is the following:
                //JMSCMQ0001: IBM MQ call failed with compcode '2' ('MQCC_FAILED') reason '2058' ('MQRC_Q_MGR_NAME_ERROR').
                if (!e.getCause().getMessage().contains("('MQRC_Q_MGR_NAME_ERROR')")) {
                    System.out.printf("%-30s => %s\n", v, e.getCause().getMessage());
                }
            }
        });
    }

    //This method require that only the queue name is missing.
    private static void discoverQueueNames(Path qDict, final JMSContext context, final boolean testForWrite) throws IOException {
        List<String> qNames = Files.readAllLines(qDict);
        System.out.printf("[+] Discover valid queue names for message %s operation (%s item names in guessing list):\n", qNames.size(), testForWrite ? "WRITE" : "READ");
        qNames.parallelStream().forEach(c -> {
            String q = c.trim();
            try {
                //As we use parallel processing then each processing bloc have it own object instances
                Destination destination = context.createQueue("queue:///" + q);
                if (destination != null) {
                    if (testForWrite) {
                        JMSProducer producer = context.createProducer();
                        producer.send(destination, "TEST");
                        System.out.printf("%-30s => Write OK\n", q);
                    } else {
                        JMSConsumer consumer = context.createConsumer(destination);
                        consumer.receiveBody(String.class, 5000);
                        System.out.printf("%-30s => Read OK\n", q);
                    }
                }
            } catch (Exception e) {
                //Error when the queue do not exist is the following:
                //JMSCMQ0001: IBM MQ call failed with compcode '2' ('MQCC_FAILED') reason '2085' ('MQRC_UNKNOWN_OBJECT_NAME').
                if (!e.getCause().getMessage().contains("('MQRC_UNKNOWN_OBJECT_NAME')")) {
                    System.out.printf("%-30s => %s\n", q, e.getCause().getMessage());
                }
            }
        });
    }

    //This methods require that only one information (property) was missing.
    //For channel names or queue manager names discovery use the dedicated methods.
    private static void discoverItems(Path itemDict, final boolean useTLS, final String connectionPropertyNameToOverride) throws IOException {
        List<String> itemNames = Files.readAllLines(itemDict);
        System.out.printf("[+] Discover valid names for property '%s' (%s item names in guessing list):\n", connectionPropertyNameToOverride, itemNames.size());
        itemNames.parallelStream().forEach(c -> {
            String v = c.trim();
            try {
                //As we use parallel processing then each processing bloc have it own object instances
                HashMap<String, String> param = new HashMap<>();
                param.put(connectionPropertyNameToOverride, v);
                try (JMSContext ctx = connectToQM(false, useTLS, param)) {
                    System.out.println(v);
                }
            } catch (Exception e) {
                //Ignore
            }
        });
    }

    private static JMSContext connectToQM(boolean printContextInfo, boolean useTLS, HashMap<String, String> paramOverrides) throws Exception {
        JMSContext context;
        JmsFactoryFactory ff = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER);
        JmsConnectionFactory cf = ff.createConnectionFactory();
        cf.setStringProperty(WMQConstants.WMQ_HOST_NAME, HOST);
        cf.setIntProperty(WMQConstants.WMQ_PORT, PORT);
        cf.setStringProperty(WMQConstants.WMQ_CHANNEL, CHANNEL);
        cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT);
        cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, QMGR);
        cf.setStringProperty(WMQConstants.WMQ_APPLICATIONNAME, "RIGHETTOD");
        if (!APP_USER.isBlank() && !APP_PASSWORD.isBlank()) {
            cf.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, true);
            cf.setStringProperty(WMQConstants.USERID, APP_USER);
            cf.setStringProperty(WMQConstants.PASSWORD, APP_PASSWORD);
        }
        if (useTLS) {
            cf.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, "*TLS1*");
        }
        if (paramOverrides != null && !paramOverrides.isEmpty()) {
            paramOverrides.forEach((key, value) -> {
                try {
                    cf.setStringProperty(key, value);
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            });
        }
        context = cf.createContext();
        if (printContextInfo) {
            System.out.println("[+] JMS context metadata");
            System.out.printf("Provider    version: %s\n", context.getMetaData().getProviderVersion());
            System.out.printf("JMS         version: %s\n", context.getMetaData().getJMSVersion());
            Enumeration props = context.getMetaData().getJMSXPropertyNames();
            System.out.print("Provider properties: ");
            while (props.hasMoreElements()) {
                System.out.print(props.nextElement() + " ");
            }
            System.out.println();
        }

        return context;
    }

    //Playground
    public static void main(String[] args) throws Exception {
        /* Item discovery */
        //discoverQueueManagerNames(Paths.get("dico.txt"), false);
        //discoverChannelNames(Paths.get("dico.txt"), false);
        //discoverItems(Paths.get("dico.txt"), false, WMQConstants.PASSWORD);
        try (JMSContext ctx = connectToQM(false, false, null)) {
            discoverQueueNames(Paths.get("dico.txt"), ctx, true);
            discoverQueueNames(Paths.get("dico.txt"), ctx, false);
        }

        /* Message operations*/
        /*
        try (JMSContext ctx = connectToQM(true, false, null)) {
            //Act on queue
            Destination destination = ctx.createQueue("queue:///" + QUEUE_NAME);
            //Write
            JMSProducer producer = ctx.createProducer();
            producer.send(destination, ctx.createTextMessage("XXX"));
            //Read
            JMSConsumer consumer = ctx.createConsumer(destination);
            String receivedMessage = consumer.receiveBody(String.class, 5000);
        } catch (Exception e) {
            System.err.printf("ERROR:\n%s\nSTACKTRACE:\n", e.getMessage());
            e.printStackTrace();
        }
        */
    }
}
